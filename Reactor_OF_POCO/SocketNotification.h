#ifndef SOCKET_NOTIFICATION_H
#define SOCKET_NOTIFICATION_H

#include "Notification.h"
#include  "Socket.h"

class SocketReactor;

//@brief a base class for notifications generated by 
//the SocketReactor;
class SocketNotification : public Notification {
 public:
  explicit SocketNotification(SocketReactor* pReactor);
  virtual ~SocketNotification();
  //return the reactor which generate the notification
  SocketReactor& source();
  //return the socket that caused the notification.
  Socket& socket();

 private:
  void setSocket(const Socket& socket);
  SocketReactor * pReactor_;
  Socket socket_;

  friend class SocketNotifier;
};

//this notification is sent when a socket become readable
class ReadableNotification : public SocketNotification {
 public:
  ReadableNotification(SocketReactor* pReactor);
  ~ReadableNotification();

};

//this notificatioin is sent when a socket becom writable
class WritableNotification : public SocketNotification {
 public:
  WritableNotification(SocketReactor* pReactor);
  ~WritableNotification();
};

//this notification is sent when a socket has signaled an error
class  ErrorNotification : public SocketNotification {
 public:
  ErrorNotification(SocketReactor* pReactor);
  ~ErrorNotification();
};

//this notification is sent when no other events occured for
//a specified time.
class TimeoutNotification : public SocketNotification {
 public:
  TimeoutNotification(SocketReactor* pReactor);
  ~TimeoutNotification();
};

//this notification is sent when the socketreactor does not have 
//any sockets to react to.
class IdleNotification : public SocketNotification {
 public:
  IdleNotification(SocketReactor* pReactor);
  ~IdleNotification();
};

class ShutdownNotification : public SocketNotification {
 public:
  ShutdownNotification(SocketReactor* pReactor);
  ~ShutdownNotification();
};


inline SocketReactor& SocketNotification::source() {
  return *pReactor_;
}

inline Socket& SocketNotification::socket() {
  return socket_;
}
#endif

